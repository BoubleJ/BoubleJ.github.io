---
date: "2024-06-15"
title: "[키워드 프로젝트] 에러 핸들링 이슈"
categories: ["Keyword"]
summary: "ErrorBoundary가 에러를 초기화 한 뒤 비동기함수 재요청 시 발생하는 에러를 해결해봅시다."
thumbnail: "./에러바운더리이미지.png"
---

# 프로젝트 설계 요약

```tsx

//Result.tsx

export default function Result({
  setResultVisible,
}: {
  setResultVisible: (value: boolean) => void;
}) {

  const apiURL = `http://localhost:3000/api/v1${pathname}${queryString}`;


  const { error, isError, data, refetch, isFetching } = FetchData(apiURL);
  useEffect(() => {
    if(queryString) {
      refetch();
      setResultVisible(true);
    }
  }, [queryString]);


  const searchData = data;

  if (isFetching) return <SkeletonContainer />;

  if (isError) {
    throw error;
  }
  return (
    <>
    
        <>
          <ExcelDownloader searchData={searchData} />
          <ResultTable searchData={searchData} />
        </>
   
    </>
  );
}
```
<br>
<br>

```tsx

//SearchPage.tsx


//생략

return 

// 생략

  {resultVisible ? (
        <ErrorBoundary
          onReset={() => {
            reset();
          }}
          FallbackComponent={({ resetErrorBoundary }) => (
            <div>
              <ErrorField
                resetErrorBoundary={resetErrorBoundary}
                setResultVisible={setResultVisible}
              />
            </div>
          )}
        >
          <Result
            setResultVisible={setResultVisible}
          />
        </ErrorBoundary>
      ) : (
        <EmptyResult />
      )}
```


<br>
<br>


```tsx

//ErrorField.tsx

//스타일컴포넌트 생략

const ErrorField = ({
  resetErrorBoundary,
  setResultVisible,

}: {
  resetErrorBoundary: () => void;
  setResultVisible: (visible: boolean) => void;

}) => {
  const handleClose = () => {
    resetErrorBoundary();
    setResultVisible(false)
  };


  return (
    <ErrorContainer>
      <Error_triangle width="5rem" height="5rem" />
      <ErrorTitle>서비스 에러가 발생했습니다.</ErrorTitle>
      <ErrorMessage>잠시 후 다시 시도하세요.</ErrorMessage>
      <Button onClick={handleClose}>돌아가기</Button>
    </ErrorContainer>
  );
};

export default ErrorField;


```


제작중인 프로젝트 에러처리 관련 코드입니다. 간략하게 설명드리자면 `Result` 컴포넌트에서 비동기함수 호출 에러 발생 시 부모 컴포넌트인 `ErrorBoundary`에서 에러를 포착하고 처리합니다. 그리고 사용자경험 증대를 위해 `fallback UI`인 `ErrorField` 컴포넌트를 보여줍니다.

`ErrorField` 내 버튼을 클릭하면 에러가 발생했던 Result컴포넌트를 에러발생 전 상태로 초기화 시키고  setResultVisible(false) 에 의해 Result 컴포넌트가 언마운트 되고 초기화면(`EmptyResult`)으로 돌아갑니다. 

<br>
<br>
<br>

# 문제점

문제는 버튼을 클릭했을 때 입니다.

![에러초기화안되는듯](에러초기화안되는듯.gif)

`ErrorField` 내 버튼을 클릭하면 에러를 초기화한 상태로 돌아가야합니다. 즉 초기화면 상태에서 다시 상품을 조회하면 `로딩창(SkeletonUI)`가 화면에 띄워져야합니다. 

하지만 위 영상처럼 로딩창이 뜨지않고 다시 에러가 발생합니다. 

![콘솔내용](콘솔내용.png)

<br>

![에러던져](에러던져.png)

실제 콘솔창을 보면 Result컴포넌트가 다시 렌더링되지만 error가 사라지지 않은채로 렌더링 되기 때문에 fallbackUI인 ErrorField가 다시 렌더링되는 것을 확인할 수 있습니다. 

에러가 컴포넌트 내에서 계속 살아있다는 의미 같은데... 뭐가 문제일까요..

<br>
<br>

## 의문점 포착

이것저것 알아보다 이상한 현상을 발견했습니다. 

위 영상처럼 에러 발생 후 다시 상품을 조회하면 error가 그대로 남아있었지만

대략 5~10분정도 지난 후 다시 상품을 조회하면 정상적으로 동작하는 것이었습니다. 

즉 시간이 지나면 에러가 사라진다는 것을 알아냈고 캐시 문제일 수도 있겠다는 생각이 들었습니다. 

<br>
<br>

# 해결

본 프로젝트는 React-Query를 사용하는데 쿼리 상태에 관련된 시간을 설정할 수 있습니다. 

stale Time, gcTime 두가지 상태가 존재하는데 별도로 설정해두지 않으면 기본 5분으로 설정됩니다. 위에서 언급했던 5~10분정도 뒤에 다시 호출하니 정상적으로 됬다 말한 시간과 비슷하죠?

```tsx

//main.tsx

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 0,
      gcTime: 0,
      retry: 0,
    },
  },
});

```

`staleTime`과 `gcTime` 를 모두 0초로 설정해두고 다시 시도해보았습니다.


![에러후재호출성공](에러후재호출성공.gif)


정상적으로 동작합니다!! 무야호!

<br>
<br>
<br>

<details>

<summary>출처</summary>

<div markdown="1">

오로지 내 머리

</div>

</details>
